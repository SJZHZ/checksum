# checksum
https://za4d3zvmtl1.feishu.cn/docx/DfrhdvOUBonPMtxlwGmcNDpQnVd
框架结构迁移到飞书文档上，本文档负责代码实现部分
## TODOLIST


## LOG
```txt

9.6
    AdlerPro(12+12)
        42343 42344
    BigMod(24)
        42345 42346

8.27
    Moduli
        0b1101001010001001u 41875 41876
        0b1101001001001001u 41877 41878
        0b1101001001001101u 41883 41884
    AdlerPro
        41879 41880 41881 41882

8.24
    1. Moduli
        0b1000011010010111 41698 41699
        0b1010011010010111 41700 41701
        0b1110000000010001 41702 41703
        0b1101000010001001 41704 41705
        0b1111000010110001&Zero 41733 41734 这个是错的。CRC才能用Zero模拟
        0b1111000010110001 41768 41769 重新测

8.23
    1. Moduli
        0xF141 41663 41664
        0xA2C1 41661 41662
        0xA0C9 41658 41659

8.22
    1. Moduli
        0xFFFF 41592 41593
        0xFFF1 41594 41595
    2. CRC
        0b1000101001100001 41596 41597
        0b1000010001101001 41598 41599
        0b1010010101101001 41602 41603

8.21
    1. CRC多项式
        0xA001: 41476 41477 
        0x1021: 41478 41479 X
        0x8408: 41480 41481
        0x8005: 41482 41483
    2. Moduli
        0b1111000010110001u: 41484 41485
        0b1101010001101001u: 41524 41526
        0b1111001010110001u: 41547 41548
        0b1101001010110001u: 41550 41551
        0b1101001010111001u: 41552 41553
        0b1100011010010101u: 41554 41555
        QOSLimit

8.20
    我脑子瓦特了，去测BER=1e-4干嘛？
    为什么不该测：
        1. 在高频错误的测试结果可以【外推】到低频错误
        2. 低频测试效率太低了，大部分情况连1bit错误都没发生，计算浪费（即使这更贴合实际）

8.19
    多测几次代表性长度：10 100

8.18
    测试各种长度（10-100，跨度10）下，CRC16和BigMod16的校验能力

```

## Problem


## Algorithm
1. Trivial  
简单累加

2. LRC  
异或叠加

3. CRC  
模2的【多项式】除法

4. None
对照实验

5. Fletcher
初值0，模数0xFFFF

6. Alder
初值1，模数0xFFF1

7. 内部Trivial外部Alder
不可能保证同态。
证明：
    设 C(1 << i) = Table[i]
    由同态性，C(1 << (i + 1)) = Table[i + 1] = 2 * Table[i] = Table[i] << 1。
    即Table[k] = Table[0] << k, 高位信息丢失。

8. 左移并除常数
有点奇怪

9. 乘以原根
尝试在Hamming Code下构造会更好


10. Pailler算法



## Parameters
1. Bit Error Ratio

1. 数据元长度  
sizeof(int)
2. 向量长度  
length
3. 算法

